<html>
<head>

<style type="text/css">
  #sigma-container {
    max-width: 100%;
    height: 100%;
    margin: auto;
    background: #3C3C3C;
  }
  
    #info-container {
    max-width: 200px;
    height: 200px;
    width: 500px;
    margin: auto;
    position: absolute;
    left: 25px;
    top: 25px;
    background-color: black;
    border-radius: 15px;
    -webkit-border-radius: 15px;
    -moz-border-radius: 15px;
    z-index: 10;
    padding: 10px;
    font-family: Gill Sans, Verdana;
    font-size: 12px;
    line-height: 18px;
    color: white;
    opacity: 0.8;
   
  }
</style>

</head>
<body>

<div id="info-container">
<strong><center><u>Phrase Details</u></center></strong>
</br>


<div id="node">
<strong>Node Id:</strong>
</div>

<div id="title">
<strong>Title:</strong>
</div>

<div id="concert">
<strong>Concert:</strong>
</div>

<div id="artist">
<strong>Artist:</strong>
</div>

<div id="raga">
<strong>Raga:</strong>
</div>

<div id="start-time">
<strong>Start-time:</strong>
</div>

<div id="end-time">
<strong>End-time:</strong>
</div>

</div>

<div id="sigma-container"></div>
<script src="sigma.min.js"></script>
<script src="sigma.parsers.json.min.js"></script>
<script src="sigma.parsers.gexf.min.js"></script>
<script src="https://code.jquery.com/jquery-1.10.2.js"></script>

<script>

   var dbase = 'http://dunya.compmusic.upf.edu/carnatic/';
  // Add a method to the graph model that returns an
  // object with every neighbors of a node inside:
  sigma.classes.graph.addMethod('neighbors', function(nodeId) {
    var k,
        neighbors = {},
        index = this.allNeighborsIndex[nodeId] || {};

    for (k in index)
      neighbors[k] = this.nodesIndex[k];

    return neighbors;
  });

   var actualGraph = new sigma();
   
  actualGraph.addRenderer({
  container: document.getElementById('sigma-container'),
  type: 'webgl',
  camera: 'cam1',
  settings: {
    defaultLabelColor: '#fff',
    defaultLabelSize: 14,
    labelColor: "node",
    defaultEdgeType: 'curve',
    maxEdgeSize: 1,
    hideEdgesOnMove: 'True',
    zoomingRatio: 3,
    borderSize: 5,
    defaultNodeBorderColor: '#FFFF'
  }
});
  
  //reading the graph file
   sigma.parsers.gexf( 
            'network_ICASSP2016_10RAGA_2S_11_pattDistance_2s_raga_close_to_sigma_frutcherman_3.gexf',
            actualGraph,
            function(s) {
      // We first need to save the original colors of our
      // nodes and edges, like this:
      s.graph.nodes().forEach(function(n) {
        n.originalColor = n.color;
      });
      s.graph.edges().forEach(function(e) {
        e.originalColor = e.color;
      });
      // When a node is clicked, we check for each node
      // if it is a neighbor of the clicked one. If not,
      // we set its color as grey, and else, it takes its
      // original color.
      // We do the same for the edges, and we only keep
      // edges that have both extremities colored.
      
      s.bind('overNode', function(e) {
        var nodeId = e.data.node.id,
            toKeep = s.graph.neighbors(nodeId);
        toKeep[nodeId] = e.data.node;
        s.graph.nodes().forEach(function(n) {
          //if (toKeep[n.id])
          //  n.color = '#FFFFFF';
        });
        s.graph.edges().forEach(function(e) {
          if (toKeep[e.source] && toKeep[e.target])
            e.color = '#FFFFFF';
        });
        // Since the data has been modified, we need to
        // call the refresh method to make the colors
        // update effective.
        s.refresh();
        
      });
      
      
      s.bind('clickNode', function(e) {
        //playing audio        
        $.ajax({
        crossDomain: true,
        dataType: 'json',
        url: "http://10.80.26.245:5000/get_phrase_data?nid="+ e.data.node.label + "&format=jsonp&callback?"
        }).then(function(data) {
            playSegment(data.mbid, data.start, data.end);
            document.body.style.cursor = "progress";
            $.ajax({
            crossDomain: true,
            dataType: 'json',
           url: "http://10.80.26.245:5000/get_rec_data?mbid="+ data.mbid + "&format=jsonp&callback?"
            }).then(function(data1) {
                console.log(data1.title);
                $("#title").html("<strong>Title: </strong>"+"<a style='color:white' href="+dbase+'recording/'+data.mbid+ ">"+ data1.title+"</a>");
                $("#concert").html("<strong>Concert: </strong>"+"<a style='color:white' href="+dbase+'concert/'+data1.concert[0]['mbid']+ ">"+ data1.concert[0]['title']+"</a>");
                $("#artist").html("<strong>Artist: </strong>"+"<a style='color:white' href="+dbase+'artist/'+data1.album_artists[0]['mbid']+ ">"+ data1.album_artists[0]['name']+"</a>");
                $("#raga").html("<strong>Raga: </strong>"+"<a style='color:white' href="+dbase+'raaga/'+data1.raaga[0]['uuid']+ ">"+ data1.raaga[0]['name']+"</a>");
                $("#start-time").html("<strong>Start-time: </strong>" + data.start);
                $("#end-time").html("<strong>End-time: </strong>" + data.end);
                $("#node").html("<strong>Node Id: </strong>" + e.data.node.label);
                
                
            });
        });
        
      });
      // When the stage is clicked, we just color each
      // node and edge with its original color.
      
      s.bind('outNode', function(e) {
        s.graph.nodes().forEach(function(n) {
          n.color = n.originalColor;
        });
        s.graph.edges().forEach(function(e) {
          e.color = e.originalColor;
        });
        // Same as in the previous event:
        s.refresh();
      });
      
      s.refresh();
    }
        );  
  

    console.log(sigma.settings);
    var settings = new sigma.classes.configurable({
        "labelThreshold": 8,
        "defaultLabelColor": "#FFF",
        "defaultEdgeType": 'curve',
        "nodesPowRatio": 0.1,
        maxEdgeSize: 1,
        hideEdgesOnMove: 'True',
        minEdgeSize: 0.1,
        maxEdgeSize: 0.5
        });
    actualGraph.settings = settings;
    actualGraph.settings('defaultLabelColor', "#FFF");
  
  
</script>
    <!--<audio id="sample" src="http://dunya.compmusic.upf.edu/document/by-id/2f274b05-9e9e-4faa-a61f-8f5d8cb6f89f.mp3" controls preload></audio>-->
    <audio id = "audioHandle"   preload="auto"></audio>

    <script>
    var audio = document.getElementById('audioHandle');
    var segmentEnd;

    audio.addEventListener('timeupdate', function (){
        if (segmentEnd && audio.currentTime >= segmentEnd) {
            audio.pause();
            document.body.style.cursor = "default";
        }   
        console.log(audio.currentTime);
    }, false);

    function playSegment(mbid, startTime, endTime){
        segmentEnd = endTime;
        audio.src = 'http://dunya.compmusic.upf.edu/document/by-id/' + mbid + '.mp3';
        console.log(audio.src);
        audio.currentTime = startTime;
        audio.play();
    }
</script>

</body>
<html>




<!--    /*ONE WAY TO MAKE AJAX CALLS (WITHOUT JQUERY)*/
//     function createCORSRequest(method, url) {
//     var xhr = new XMLHttpRequest();
//     if ("withCredentials" in xhr) {
//         // XHR for Chrome/Firefox/Opera/Safari.
//         xhr.open(method, url, true);
//     } else if (typeof XDomainRequest != "undefined") {
//         // XDomainRequest for IE.
//         xhr = new XDomainRequest();
//         xhr.open(method, url);
//     } else {
//         // CORS not supported.
//         xhr = null;
//     }
//     return xhr;
//     }
 
//var xmlhttp = new createCORSRequest('GET', "http://127.0.0.1:5000/get_phrase_data?nid=1&format=jsonp&callback?");
//xmlhttp.send()
//xmlhttp.onreadystatechange = function() {
//if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
//    var myArr = JSON.parse(JSON.stringify(xmlhttp.responseText));
    //   console.log(myArr);
//}
//}-->
